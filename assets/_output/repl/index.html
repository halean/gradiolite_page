<!DOCTYPE html>
<html>
  <head>
    <title>REPLite</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="Description" content="WASM powered Jupyter running in the browser." />
    <link rel="manifest" href="../manifest.webmanifest" />
    <link
      id="jupyter-lite-main"
      rel="preload"
      href="../build/repl/bundle.js?_=daaafe0"
      main="index"
      as="script"
    />
    <script
      id="jupyter-config-data"
      type="application/json"
      data-jupyter-lite-root=".."
    >
      {}
    </script>
    <script>
      (async function () {
        const { pathname, origin, search, hash } = window.location;
        if (pathname.match(/(index.html|\/?)$/) == null) {
          window.location.href = `${origin}${pathname}/${search}${hash}`;
          return;
        }
        await import(
          '../config-utils.js?_=daaafe0'
        );
      }.call(this));
    </script>
    <style>
      body {
        margin: 0;
        padding: 0;
        transition: background-color 0.3s ease;
      }

      body {
        background-color: #fff;
        color: #000;
      }

      body.jp-mod-dark {
        background-color: #111;
        color: #fff;
      }

      #jupyterlite-loading-indicator {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 1000;
        opacity: 0; /* Hidden by default */
        transition: opacity 0.5s ease-out;
        display: none; /* Hidden by default */
      }

      #jupyterlite-loading-indicator.hidden {
        animation: fadeOut 0.5s ease-out forwards;
        pointer-events: none;
      }

      /* Show the indicator when needed */
      #jupyterlite-loading-indicator:not(.hidden) {
        opacity: 1;
        display: block;
      }

      .jupyterlite-loading-indicator-spinner {
        width: 60px;
        height: 60px;
        margin: 0 auto 20px;
        border: 6px solid rgba(0, 0, 0, 0.1);
        border-top: 6px solid #FFDC00; /* Bright yellow color */
        border-radius: 50%;
        animation: jupyter-spin 1s linear infinite;
      }

      body.jp-mod-dark .jupyterlite-loading-indicator-spinner {
        border: 6px solid rgba(255, 255, 255, 0.1);
        border-top: 6px solid #FFDC00;
      }

      .jupyterlite-loading-indicator-text {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
        font-size: 16px;
      }

      /* Adjust text color based on theme */
      body.jp-mod-light .jupyterlite-loading-indicator-text {
        color: #000000;
      }

      body.jp-mod-dark .jupyterlite-loading-indicator-text {
        color: #ffffff;
      }

      @keyframes jupyter-spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      @keyframes fadeOut {
        0% { opacity: 1; }
        100% { opacity: 0; }
      }
    </style>
  </head>
  <body class="jp-ThemedContainer" data-notebook="repl">
    <div id="jupyterlite-loading-indicator" class="hidden">
      <div class="jupyterlite-loading-indicator-spinner"></div>
      <div class="jupyterlite-loading-indicator-text">Loading JupyterLite...</div>
    </div>
    <noscript>
      <div style="text-align: center; padding: 20px;">
          JupyterLite requires JavaScript to be enabled in your browser.
      </div>
    </noscript>
  </body>
  <script>
    (function () {
      if (window.__jl_bridge_installed) return;
      window.__jl_bridge_installed = true;

      const delay = (ms) => new Promise((r) => setTimeout(r, ms));
      function trigger(node, type) {
        if (!node) return;
        node.dispatchEvent(new MouseEvent(type, { bubbles: true, cancelable: true }));
      }
      function clicks(node) {
        trigger(node, 'mouseover');
        trigger(node, 'mousedown');
        trigger(node, 'mouseup');
        trigger(node, 'click');
      }

      async function setCodeAndRun(code, autorun = true) {
        try {
          // Clear toolbar (prefer console:clear; fallback to repl:clear)
          let clearBtn =
            document.querySelector("jp-button[data-command='console:clear']") ||
            document.querySelector("button[data-command='console:clear']") ||
            document.querySelector("[data-command='console:clear']") ||
            document.querySelector("jp-button[data-command='repl:clear']") ||
            document.querySelector("button[data-command='repl:clear']") ||
            document.querySelector("[data-command='repl:clear']");
          if (clearBtn) {
            clicks(clearBtn);
            await delay(200);
          }

          // Find prompt editor (CodeMirror)
          let content =
            document.querySelector('.jp-ConsolePanel .cm-content') ||
            document.querySelector('.cm-content') ||
            document.querySelector('.cm-editor');
          let tries = 0;
          while (!content && tries < 60) {
            await delay(50);
            content =
              document.querySelector('.jp-ConsolePanel .cm-content') ||
              document.querySelector('.cm-content') ||
              document.querySelector('.cm-editor');
            tries++;
          }
          if (!content) return { ok: false, reason: 'no-editor' };
          content.focus();
          trigger(content, 'click');

          // Insert code (paste → insertText → before/input → last resort)
          let setOk = false;
          
          if (!setOk) {
            const lines = document.getElementsByClassName('cm-line');
            if (lines && lines.length) {
              try {
                lines[lines.length - 1].textContent = String(code);
              } catch (e) {}
            }
          }

          await delay(150);
          if (autorun) {
            let runBtn =
              document.querySelector("jp-button[data-command='console:run-forced']") ||
              document.querySelector("button[data-command='console:run-forced']") ||
              document.querySelector("[data-command='console:run-forced']") ||
              document.querySelector("jp-button[data-command='repl:run']") ||
              document.querySelector("button[data-command='repl:run']") ||
              document.querySelector("[data-command='repl:run']");
            if (runBtn) {
              clicks(runBtn);
            } else {
              const ed = content;
              const kd = new KeyboardEvent('keydown', {
                key: 'Enter',
                code: 'Enter',
                keyCode: 13,
                which: 13,
                shiftKey: true,
                bubbles: true,
              });
              const ku = new KeyboardEvent('keyup', {
                key: 'Enter',
                code: 'Enter',
                keyCode: 13,
                which: 13,
                shiftKey: true,
                bubbles: true,
              });
              ed.dispatchEvent(kd);
              ed.dispatchEvent(ku);
            }
          }

          // Capture last output
          let outText = '';
          let outHTML = '';
          let beforeCount = document.querySelectorAll('.jp-OutputArea-output').length;
          let start = Date.now();
          while (Date.now() - start < 8000) {
            await delay(200);
            const outs = document.querySelectorAll('.jp-OutputArea-output');
            if (outs.length > beforeCount) {
              const last = outs[outs.length - 1];
              outText = last.innerText || '';
              outHTML = last.innerHTML || '';
              break;
            }
          }
          return { ok: true, text: outText, html: outHTML };
        } catch (e) {
          return { ok: false, reason: String(e) };
        }
      }

      window.addEventListener('message', async (e) => {
        if (e.origin !== location.origin) return;
        const data = e.data || {};
        if (data.type === 'seed-code') {
          const code = String(data.code || '');
          const autorun = data.autorun !== false;
          const res = await setCodeAndRun(code, autorun);
          window.parent.postMessage(
            { type: 'bridge:result', ok: !!res.ok, text: res.text || '', html: res.html || '' },
            location.origin
          );
        }
      });

      // Notify the parent that the bridge is ready
      try { window.parent.postMessage({ type: 'bridge:ready' }, location.origin); } catch (_) {}
    })();
  </script>
</html>
